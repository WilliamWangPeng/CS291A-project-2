require 'sinatra'

# get a specific file by its name which is in SHA256
get '/files/:digest' do
	# for getting buckets, got from https://googleapis.dev/ruby/google-cloud-storage/latest/index.html
	require "google/cloud/storage"

	# primitive check, I believe it might be impossible to
	# check whether a hash was generated by using SHA256
	# so just checking validity of hex 
	# found at https://stackoverflow.com/questions/9075515/ruby-check-if-string-is-all-valid-hex-characters
	# and length of hash :)
	if !params['digest'][/\H/] &&
		 params['digest'].length == 64

		# getting storage and bucket
		storage = Google::Cloud::Storage.new(project_id: 'cs291-f19')
		bucket = storage.bucket 'cs291_project2', skip_lookup: true

		# creating file name same as in server
		file_name = params['digest'].insert(2,'/')
		file_name = file_name.insert(5, '/')
		file_name.downcase!

		# get file if it exists
		file = bucket.file file_name, skip_lookup: true

		# throw 404 if file does not exist
		if !file.exists?
			status 404
			headers["Content-Type"] = "application/json"
			return {:message => "File not found"}.to_json
		end

		begin
			# set content-type same as that of file
			headers["Content-Type"] = file.content_type.to_s
			# download the file to read it
			downloaded = file.download
			content = downloaded.read

		rescue Google::Cloud::NotFoundError => e # just in case
			status 404
			headers["Content-Type"] = "application/json"
			{:message => "File not found"}.to_json
		end

	else # invalid file name (hash)

		status 422
		headers["Content-Type"] = "application/json"
		{:message => "Invalid file name"}.to_json

	end
end

# get names for all the valid files
get '/files/' do
	# for getting buckets, got from https://googleapis.dev/ruby/google-cloud-storage/latest/index.html
	require "google/cloud/storage"

	begin
		# getting storage and bucket
		storage = Google::Cloud::Storage.new(project_id: 'cs291-f19')
		bucket = storage.bucket 'cs291_project2', skip_lookup: true
		
		# get all files
		all_files = bucket.files
		
		# get the names of all valid ones
		all_file_names = Array.new
		all_files.all { |file|
			file_name = file.name

			# checking validity before pushing
			file_name_split = file_name.split('/')

			if file_name_split.length == 3 &&
				 file_name_split[0].length == 2 &&
				 file_name_split[1].length == 2 &&
				 file_name_split.join.length == 64

				all_file_names.push file_name_split.join

			end
		}

		# setting content type
		headers["Content-Type"] = "application/json"

		# return sorted array
		all_file_names.sort.to_s

	rescue Google::Cloud::PermissionDeniedError => e # if there is any permission error
		status 403
		headers["Content-Type"] = "application/json"
		{:message => e.message}.to_json
	end
end

# just redirect to /files/
get '/' do
	# set status
  status 302
  # set redirect location
  # found at https://stackoverflow.com/questions/2950234/get-absolute-base-url-in-sinatra#comment3015571_2952576
  headers["location"] = "/files/"
  # don't want body
  ""
end

# delete a specific file by its name which is in SHA256
delete '/files/:digest' do
	# for getting buckets, got from https://googleapis.dev/ruby/google-cloud-storage/latest/index.html
	require "google/cloud/storage"

	# primitive check, I believe it might be impossible to
	# check whether a hash was generated by using SHA256
	# so just checking validity of hex 
	# found at https://stackoverflow.com/questions/9075515/ruby-check-if-string-is-all-valid-hex-characters
	# and length of hash :)
	if !params['digest'][/\H/] &&
		 params['digest'].length == 64

		# getting storage and bucket
		storage = Google::Cloud::Storage.new(project_id: 'cs291-f19')
		bucket = storage.bucket 'cs291_project2', skip_lookup: true

		# creating file name same as in server
		file_name = params['digest'].insert(2,'/')
		file_name = file_name.insert(5, '/')
		file_name.downcase!

		# get file if it exists
		file = bucket.file file_name, skip_lookup: true

		# delete if file exists, don't care if it does not exist
		if file
			begin
				file.delete
				""
			rescue Google::Cloud::NotFoundError => e
				status 200
			end
		end

	else # invalid file name (hash)

		status 422
		headers["Content-Type"] = "application/json"
		{:message => "Invalid file name"}.to_json

	end
end

# create a new file
post '/files/' do

	require 'digest'
	# for getting buckets, got from https://googleapis.dev/ruby/google-cloud-storage/latest/index.html
	require "google/cloud/storage"

	# checking if file is provided or not
	if !params["file"]
		status 422
		headers["Content-Type"] = "application/json"
		return {:message => "File not provided"}.to_json
	end

	# the file is stored in tempfile
	file = params["file"]["tempfile"]

	# if the file is not provided
	if !file
		status 422
		headers["Content-Type"] = "application/json"
		return {:message => "File not provided"}.to_json
	end

	# if the file is not provided
	if !File.file?(file)
		status 422
		headers["Content-Type"] = "application/json"
		return {:message => "File not provided"}.to_json
	end

	# reading the contents of the file
	content = file.read

	# throwing error if file size greater than 1 MB (1024*1024 BYTES)
	if content.length > 1048576
		status 422
		headers["Content-Type"] = "application/json"
		return {:message => "File size too big (greater than 1 MB)"}.to_json
	end

	# hashing the contents in hex
	content_hash = Digest::SHA256.hexdigest content

	# file name in the gcs
	file_name = content_hash.insert 2, "/"
	file_name = file_name.insert 5, "/"

	# getting storage and bucket
	storage = Google::Cloud::Storage.new(project_id: 'cs291-f19')
	bucket = storage.bucket 'cs291_project2', skip_lookup: true

	# looking for the file with same contents in the gcs
	server_file = bucket.file file_name, skip_lookup: true

	# throw 409 if file already exists
	if server_file.exists?
		status 409
		headers["Content-Type"] = "application/json"
		return {:message => "Conflict file already present"}.to_json
	end

	# if here means the file does not exist
	bucket.create_file file, file_name, content_type: params["file"]["type"].to_s
	status 201
	headers["Content-Type"] = "application/json"
	{:uploaded => "#{content_hash.split("/").join}"}.to_json
end
